# -*- fill-column: 80; abbrev-mode: t; paredit-everywhere-mode: t; -*-

* Specific Machine Structure
** Simulated Computers
   A computer may be built or it may be simulated or it may be emulated. The
   first is called a 𝘭𝘪𝘵𝘦𝘳𝘢𝘭 machine and actually exists, consisting of chips
   and wires that can be felt and occupy space. The second and third are
   nonexistent machines, but exist logically. They are called 𝘷𝘪𝘳𝘵𝘶𝘢𝘭
   machines. The distinction between simulation and emulation is that simulation
   is done by writing a program and executing it on some host computer, while
   emulation is done in hardware. Emulation is generally faster in execution
   than simulation but lacks the flexibility of easy program modification. There
   is even a compromise approach, in which a micro-program is loaded into an
   emulator, that tries to combine speed of execution with flexibility. There
   are many reasons to have virtual machines. A computer vendor might encourage
   the sales of their[sic] computers by including emulation hardware that
   imitates the commands of a competitor's machine. This would encourage the
   sale of their[sic] 𝘣𝘦𝘵𝘵𝘦𝘳 machine without the customer having to sacrifice
   the present inventory of programs written in the the competitor's machine
   language. Another use, using emulation for high speeds, is to design virtual
   machines that have their 𝘮𝘢𝘤𝘩𝘪𝘯𝘦 𝘭𝘢𝘯𝘨𝘶𝘢𝘨𝘦 one of the higher level languages,
   such as Pascal or Ada, in order to completely avoid program translation.
   Simulated computers might be used there the need for speed is second to
   flexibility, as in the evaluation of new computer designs before actual
   production begins or to provide testing of programs before prototypes are
   constructed. Another reason of simulation is to provide a machine structure
   for educational purposes.

** The SHAM Computer
   The SHAM computer (an acronym of simplified hypothetical alphanumeric
   machine) is a virtual, or simulated, machine that can be used to study the
   principles of system programming without concern about the limitations,
   availability, or complications of a real machine. SHAM is a simulated
   computer designed for educational purposes. It is simplified to avoid
   cumbersome and educationally unimportant details but has typical machine
   structure from a programmer's viewpoint. The use of SHAM provides for
   portability of the exercises and examples used to teach system programming
   and permits the student to avoid the choking details that must be faced with
   literal machines before anything may be done. The concept of a VM is widely
   used, even to the extent of a large mainframe computer witching from one
   virtual machine to another at millisecond intervals so that each user on such
   a time-slicing system may have a completely different machine to work with. A
   VM simulation is accomplished by writing the behavior of a virtual machine in
   a high level language, compiling this program to the low level hardware
   language of some host computer, and executing the resultant program which
   then behaves as though it were a computer: in this case the SHAM computer.
   The SHAM computer is written in the C language.[fn:1]

** SHAM Overview
   The structure of SHAM is selected to reflect the performance of a typical
   computer, to provide a target computer for the design of operating systems,
   and to provide irritating machine limitations that are so typical of real
   computers. The latter point is included to give realistic experience of the
   type encountered when designing operating systems for actual computers. As an
   example of ease of usage, SHAM includes an instruction to place a random
   number in the AX register. No real machine provides this, a software routine
   is always required. Thus, SHAM makes it simple to generate test data to
   evaluate its performance in different situations. On the other hand, the use
   of SHAM requires attention to different methods of addressing: absolute
   addressing, relative addressing using the DR register, stack addressing with
   the SR register, special behavior of the FX register, and indirect
   addressing. These peculiarities of one machine versus another are a major
   reason for the difficulty in porting operating system software from one
   machine environment to another. Finally, being written in a high level
   language the SHAM computer may be easily modified to study the impact of
   machine structure on system software design and performance.

   It is assumed that SHAM will be implemented on a host computer that has a
   keyboard for data entry, a video display for standard output, and a secondary
   memory for simulation of SHAM's disk memory and streaming input. No printer
   is involved in the SHAM system and  any hard copy will have to be provided by
   the host system, perhaps by redirecting the standard output to a file for
   subsequent printing. The host machine secondary memory will actually hold
   four files: SHAM.ROM, SHAM.STM, SHAM.DSK and SHAM.TXT, The first will
   simulate a ROM, or read only memory, on which the operating system program
   will be stored. When SHAM is activated, that program will automatically load
   into the SHAM internal RAM memory beginning at address location 0. The
   program will start executing from location 0 after loading is completed; this
   simulates the IPL or initial program loading of all computers, In the SHAM
   system, the contents of SHAM.ROM may not be directly addressed: assume that
   the RAM memory is faster than the ROM memory and that the transfer from ROM
   to RAM is to take advantage of that fact. the RAM memory is volatile; i.e.,
   its contents disappear when the power is turned off (a SHAM session is
   terminated) while the ROM memory is permanent. The second file (SHAM.STM) is
   designed to be an auxiliary ROM memory that may contain a machine procedure
   that could be dynamically loaded by the operating system and will serve as a
   vehicle for transferring a machine language (non-text) file onto the
   SHAM.DSK. The last two files (SHAM.DSK and SHAM.TXT) will be used to simulate
   a single disk drive (SHAM.DSK) and the cassette (SHAM.TXT) for secondary
   memory storage. It is anticipated that the operating system will be written
   that will 𝘧𝘰𝘳𝘮𝘢𝘵 the simulated disk drive to whatever number of 256 byte
   sectors is desired. Data and programs will be stored by SHAM machine language
   programs using commands that read from and write to disk (SHAM.DSK). The text
   file (SHAM.TXT) may be used by SHAM programs to input a stream of bytes into
   the SHAM primary memory.

   SHAM is deliberately limited in its design in order to achieve simplicity.
   Those structures that do not relate to operating system design are omitted.
   There is but a single disk drive There is no floating point, only small
   integer arithmetic is permitted. There is no divide overflow interrupt. SHAM
   does not provide relative timing in its simulation. The commands do take
   different real time intervals for execution depending on their complexity but
   there is, for example, no attempt to simulate the tremendous differences in
   steed between register aces and primary memory access, which differ by factors
   up to several thousand in real machines.

   Certain commands are missing in SHAM that might be found in other processors.
   There are, for example, no bit manipulation commands in SHAM. There are no
   register shift op-codes. The flag register will only indicate three level and
   is not used to record results of arithmetic carry or of divide overflow or of
   parity failure in data manipulation.

** Input and Output Operations
   There are four peripheral i-o devices on SHAM, a keyboard input, a video output
   call Input-Output, a video output call [sic] Display and the tape-like file
   called Textile (SHAM.TXT). The two video devices (input-Output and Display)
   are displayed side by side on the host machine video display output. All of
   these input-output devices are one character at a time units. The characters
   are transferred directly into or from primary memory locations without
   interference with processor or secondary memory access. There is no direct
   connection between the registers and output ports and characters will have to
   stored [sic] in memory and then outputted. Non-graphic characters are
   handled differently on SHAM than many machines (but that is true for those
   many machines, i-o differences make operating system potability a problem).
   On the Input-Output display, the backspace will move the cursor backwards
   (its[sic] the only cursor control) and will output the character previously
   displayed in white ink as opposed to the normal black ink, thus erasing the
   previously displayed character. The carriage return acts like the carriage
   return on old-fashioned typewriters; i.e., it not only returns the cursor to
   the leftmost position but it issues a line feed. The combustion carriage
   return and line feed, required on some computers, is not needed on SHAM. The
   ASCII control character for carriage-return[sic] is encoded as the number 13.
   There is no cursor control for the display units and no graphic facilities,
   just character output. There is no on-line printer, thus avoiding the problem
   of escape sequences, but the Display video acts like a printer in that no
   backspace may take place. There are no communication ports. There are no
   light pen or mouse inputs.
** Primary and Secondary Memory
   The internal memory, or RAM, is simulated to be 32678 bytes of storage that
   will volatilize when the SHAM program is terminated. The 32K bytes in the RAM
   are addressable from 0 through 32677. In addition to byte addressing, word
   referencing is permitted by commands that fetch or store two contiguous
   bytes. This is true for all addresses, whether odd or even. except for the last
   byte at 323677; there is no byte following that one (the memory is not
   circular).

   The single 32 KB primary memory is used to store both programs and data.
   Certain addresses in lower memory should be avoided in programming; as with
   many computers these locations are reserved for machine purposes, such as an
   interrupt vector. It would have been simple to make the SHAM primary memory
   larger. all that is required is to change the dimension in the memory
   descriptor in the source program:

   #+BEGIN_SRC c
   #define MEM_SIZE 32768
   char memory[MEM_SIZE];  /* SHAM internal memory */
   #+END_SRC

   However, the use of the smaller 32 KB memory will ensure the design of an
   operating system that efficiently utilizes memory allocation. The same point
   can be made about the SHAM word size, which is 16 bits (two bytes), A simple
   change in the source program to define the integers as 𝘭𝘰𝘯𝘨 would suffice,
   but the smaller word forces the designer to be more conscious of hardware
   limitations.

   The secondary memory simulates a disk drive, with fixed sector size of 256
   bytes. An entire sector is read to or written from primary memory by machine
   command. There is no hardware buffer, the sector is coped directly into or
   from primary memory starting at any specified address low enough from 32677 to
   allow for a full sector (there is no memory wraparound). The timing of the
   sector transfer is determined by the host computer since the SHAM.DSK drive
   is simulated by a host computer disk file.

** The Fetch-Execute Cycle
   The design of a computer requires a working memory to hold the stored program
   and a processing unit to interpret the commands of the program and effect
   their execution. In the simplest case, a program consists of a sequence of
   commands that are stored in some high speed memory accessible to the
   processing unit.  A command is copied from the memory into a small storage unit
   called a command register. The command register is not available to the
   programmer. The command will consist of a series of bits and might look
   something like this:
   #+BEGIN_SRC asm
   0110110101110010
   #+END_SRC
   That particular combination of bits, represented by a sequence of bistable
   devices in the command register, would cause the processing unit to initiate
   some simple action, such as: add two numbers. Such an action would be only
   one in a long series of steps required to direct the computer to obtain some
   meaningful results. The processing unit would then fetch the next command in
   sequence to the command register, erasing the previous command, and replacing
   it with something like:
   #+BEGIN_SRC asm
   1001101111011111
   #+END_SRC
   which might direct the processing unit to multiply the previous sum be a
   third number. These two steps:
   1. fetch the next command in the program
   2. interpret and execute that command
   are the heart beat of the computer. The processing unit repeats that cycle
   endlessly: fetch and execute. The actions of the computer are entirely the
   result of the bit patterns stored in the program memory. These bit patterns
   are store in some magnetic or electronic device; the exact device depending
   on he type of computer and the year in which it was built. Programmers who
   can create these bit patterns and enter then[sic] into the correct locations
   in program memory are programming at the machine level of detail and this
   action is referred to a machine language programming.

** C Simulation Program
   The following C language function is the main cycle of the SHAM computer:
   #+BEGIN_SRC c
   main() {
       char memory[MEM_SIZE]; /* SHAM internal memory. */
       r1 = 0;                /* Boot from SHAM.ROM.   */
       stream(memory);

       /* The cycle is repeated endlessly. */
       while (1) {
           fetch(memory);    /* Fetch instruction.  */
           execute(memory);  /* Execute instruction. */
       }
   }
   #+END_SRC
   The memory is declared as an array of type character with a size specified by
   MEM_SIZE (which is 32678.) The subscripts for this array may range from 0
   to 32577. The first action of the "main" procedure is to "boot up" by reading
   the file SHAM.ROM into memory starting at zero, by calling the function
   stream(memory) with r1 set to zero. Then SHAM (until a TERMINATE instruction
   is executed) fetches the next instruction from memory and then executes that
   instruction via a call to a different C function (not shown here) for each
   instruction.

** The Processing Unit
   The structure of the processing unit consists of the high speed registers
   and the circuitry required to analyze the command bit pattern and to control
   the rest of the computer. This circuitry determines the command repertoire of
   the particular machine. To properly utilize a computer, the machine level
   programmer must know what that repertoire is. Computers manufactured by
   different vendors will have dissimilar command sets, and frequently,
   different models within one vendor will too. This means that a programmer who
   knows how to program one machine; i.e., to create the bit patterns to control
   the computer cannot use that knowledge to program any other type of computer.
   In addition to the command register and the control circuitry, the processing
   unit requires a "next location" register which enables the unit to fetch the
   next command in proper sequence. Remember, fetch is a copy operation, and
   the original commanded in the program memory is not destroyed or altered by
   being fetched. The next location register, also called the instruction
   pointer register, is automatically changed after the fetch (and sometimes by
   the program command itself in the execute phase) so that it points to the
   next command to be executed. How the location register is initialized to
   point to the first command in the program varies from one machine to
   another, but one solution is to have the programs always start from the same
   location in memory. In SHAM , the IP (instruction pointer) register is set to
   zero when the simulation program is initiated (Initial Program Load is what it
   is called) and all application programs must start with their first command
   in location zero of the SHAM primary memory.

   There are other registers in the processing unit. These are often combined
   with the registers in the computer's arithmetic and logical unit as general
   purpose registers. These registers are used in address modifications as well
   as arithmetic calculations.

** Register Memory
   There are eleven registers in SHAM. All registers are of word length (16
   bits), All arithmetic is word oriented and of integer mode; there are no
   floating point or real arithmetic commands in the SHAM repertoire. Five
   registers are general purpose: these are named the AX, BX, CX, DX, and EX
   registers. The FX register (sometimes referred to as the frame register) is
   similar except that when it appears as the second register in a four-byte
   SHAM command the SR (stack register) contents are added to the FX contents
   rather than the DR (data register) which is done for all other relative
   addressing. In addition to these six, there are the DR, IP, SR, SP, and the
   FR registers. The FR is a flag register, and although it is 16 bits long, is
   used only to contain a flag of value -1, 0, +1 to indicate the result of a
   previous compare command. The DR register is used as the base register for
   procedure relocation. The contents of the IP register, the command address
   offsets, and the indirect addresses in other registers are each added to the
   contents of DR before execution to produce a machine memory address that is
   the sum of some base address and some displacement. The IP register is the
   instruction pointer and contains the address of the next command in memory
   to be fetched and executed. The SP (stack register)contains the base address
   of some location in memory to be used in stack addressing(in such commands as
   PUSH, POP, CALL, and RETURN). The SP (stack pointer) contains an offset that
   is added to the contents of SR to create the actual stack address and it is
   the SP register that is changed by a command such as PUSH or POP. The
   contents of DR,IP, SR, and SP are set during IPL. The value of DR and IP are
   each set to zero, so that the program in ROM must start execution at absolute
   address of zero. The contents of SR are set by IPL to a value just larger
   than the program read in from ROM so that the first stack established lies in
   the memory jut after the ROM program. The value of SP is set to 600, so tat
   there is an initial stack large enough for most application,. The user
   program may change any of these values subsequently. In summary:
         +------------------------------------------------------------+
         |           SHAM high-speed 16 bit register memory           |
         +-----+------------------------------------------------------+
         | AX  |Five general purpose arithmetic registers.            |
         +-----+                                                      |
         | BX  |                                                      |
         +-----+                                                      |
         | CX  |                                                      |
         +-----+                                                      |
         | DX  |                                                      |
         +-----+                                                      |
         | EX  |                                                      |
         +-----+------------------------------------------------------+
         | FX  |Frame register (may be used in arithmetic).           |
         |     |                                                      |
         +-----+------------------------------------------------------+
         | DR  |Restricted to point to the next instruction to be     |
         +-----+fetched.                                              |
         | IP  |                                                      |
         +-----+------------------------------------------------------+
         | SR  |Restricted to point to a user specified stack in      |
         +-----+memory.                                               |
         | SP  |                                                      |
         +-----+------------------------------------------------------+
         | FR  |Flag register (set by compare command and used by     |
         |     |conditional branch commands.                          |
         |     |                                                      |
         +-----+------------------------------------------------------+

** Interrupts and Reserved Vector
   No modern computer would be without an interrupt scheme. In SHAM, the
   interrupt is limited to a clock driven interrupt. There is no interrupt for
   pressing a key on the keyboard, no interrupt for a completion of I/O, no
   interrupt for a program error such as divide overflow, in fact, no other
   interrupt at all. This clock drive interrupt allows for an interrupt to occur
   when a quantum of time has elapsed. The 𝘤𝘭𝘰𝘤𝘬 is not a real time clock; it
   starts at zero on IPL and increments itself once on every command execution.
   In a real computer, different commands use different times for execution: a
   multiply command is much longer than a move command. The clock value (a 16
   bit integer) is compared by SHAM with the value currently stored in location
   0 and 1 (a two byte word). An interrupt occurs when the clock equal the stored
   value: the values of UR, DR, and IP are stacked on the current stack, at
   location (SR) + (SP), an control is transferred to the procedure whose IP and
   DR values are stored in location 12 and 14 (each a wold long, the IP value is
   in bytes 12 and 13, the DR value in bytes 14 and 15). These values are not
   placed there automatically, some program must do so. There are two,
   opcodes (ENABLE and DISABLE) that may be used by the application program: the
   execution of an ENABLE is required to start increasing the clock value and
   permit an interrupt; a DISABLE will discontinue increasing the clock value
   until another ENABLE command is reached, if ever. The basic C language
   simulation program can now be expanded to include this interrupt, as follows:
   #+BEGIN_SRC c
     main() {
         char memory[MEM_SIZE];                          /* SHAM internal memory. */
         int limit, clock = 0;                           /* These are used for the interrupt. */
         r1 = 0;                                         /* Boot from SHAM.ROM. */
         stream(memory);
         /* The cycle is repeated endlessly. */
         while (1) {
             fetch(memory);                              /* Fetch instruction. */
             execute(memory);                            /* Execute instruction. */
             if (enable_flag) {                          /* Increment clock only if enable has been set. */
                 limit = (memory[0] << 8) | memory[1];
                 if (++clock == limit) {
                     clock = 0;                          /* On interrupt, execute procedure whose */
                     clock_int(memory);                  /* IP, DR are at location 12 & 14. */
                 }
             }
         }
     }
   #+END_SRC
   The clock variable is increased by one on each fetch-execute cycle and when
   it equal the value in the first word of memory causes a transfer of control
   to a SHAM program whose starting location must have been previously stored in
   words 12 and 14. The integer variables limit and clock (initialized to zero)
   are used in the segment that handles the interrupt. The value of limit is
   calculated by
   #+BEGIN_SRC c
   limit = (memory[0] << 8) | memory[1]
   #+END_SRC
   which 𝘣𝘪𝘵 𝘰𝘳𝘴 the first byte of memory (shifted left 8 bits) with the second
   byte: this is the value of the first word in the SHAM memory.

   This simple example demonstrates the usefulness of the virtual computer
   concept. SHAM could be originally written without the clock interrupt — then
   a slight modification of the C source program and a recompile would create a
   new SHAM computer.

** Instruction Format
   Every command to be executed by the processing unit is divided into three
   parts: the operation code part, a miscellaneous or multipurpose part, and a
   data address part. Each command contains a string of bits that cause the
   execution of one of the built-in operations. This is the operation code
   portion, usually abbreviated to opcode and is used to tell the computer what
   to do; as the fetch_word command copies a word of data from the primary
   memory to a general purpose register or a multiply opcode multiplies the
   contents of one register by another's contents and places the value in the
   first register, and so on. Another portion of the command is set aside to
   refer to the data address or location in addressable memory where the
   reference data are stored. The fetch_word opcode will copy from some location
   in memory; that location is specified by the data address portion of the
   command. The third, or miscellaneous, portion of the command is used to refer
   to which register is to be loaded or changed, to which subordinate action of
   the opcode is to be executed, and as a general catch-all for different
   computer system needs. A bit pattern for a command, say
   000110100100000001011, would be partitioned by the processing unit into:
                          +----------+--------------+
                          |00011010  |opcode        |
                          +----------+--------------+
                          |0100      |miscellaneous |
                          +----------+--------------+
                          |00001011  |data address  |
                          +----------+--------------+
   which might mean: fetch the two bytes of storage (00011010) into the first
   general purpose register (0100) from memory location 00001011. It will be
   awkward to continue to describe the machine level programs in their correct
   bit code, so the opcodes are usually referred to by some mnemonic (such as
   fetch_word), and the registers by some letter combinations (such as: AX, BX,
   CX, etc.), and the data address by some symbolic name (such as: INITIAL) so
   that the example command would be written something like:
   #+BEGIN_SRC asm
   fetch_word  AX,,INITIAL
   #+END_SRC
   This notation would have no meaning to the processing unit and the machine
   level programmers must convert that symbolic command into
   000110100100000001011 before the program is entered into the computer and
   executed. The solution, of course, is not to program in machine language.
   Although all computers must have a machine level program stored in their
   memory before anything can be accomplished, there is no need for that program
   to be written by a human. A translating program of some type can be written
   to convert human oriented notation to the requirements of the machine.

   The instruction format in SHAM is of variable length: using one byte for
   simple commands, two, bytes for longer commands, and four bytes for the most
   complicated commands. This design reduces the required program storage but
   places a slight burden on the programmer when compared to the fixed command
   length machines. The location of a command is the address of its first byte.
   Upon fetching one command, the contents of IP is automatically increased by
   the length of that command so that IP will then point correctly to the next
   command to be executed. Examination of the IP register before the execution
   cycle. will show the IP pointing to the next command, not the current one.
   The structure of the three lengths of commands is:

       one byte:        (opcode)

       two bytes:       (opcode)    (reg1 reg2)

       four bytes:      (opcode)    (reg1 reg2)    ((data address))

   where the parentheses indicate byte allocation; one byte for an opcode, one
   byte for the two, registers (reg1 is in the left four bits, reg in the right
   four bits), and two bytes for the address (a 16 bit number). The opcodes are
   numbers from 0 co 30, any other number is an invalid code. The registers are
   number from one to eleven, one of AX and eleven for FR, in these order:
      +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
      | AX  | BX  | CX  | DX  | EX  | FX  | DR  | IP  | SR  | SP  | FR  |
      +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
      |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  |
      +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+

** Primary Memory Addressing
   The addressing in SHAM, as with most computers, is a t three levels: an
   absolute address, a relative address, and an indirect address. An absolute
   address refers to a location in the memory from 1 to 32677. Location 0 cannot
   be used as an absolute address in a SHAM instruction because an absolute
   address is indicated by a negative value and negative zero is not allowed. An
   absolute data address in the data address portion of a command refers
   directly to one of the byte locations in a memory. A relative address is one
   that is an offset from some base, modified perhaps by an index value. The
   contents of the DR register is always used as the base register; it is not
   described in the command and its contents are automatically added to the data
   address before execution. Besides that addition, the contents of another
   register (called the index register in this context) will also be added in if
   its number is given in the reg2 position. Any register except FX may be used
   as an index register. If the contents of the right nibble of byte two, is zero
   (reg2 = 0) no register is used for indexing. The memory location referred to
   by a relative address is:
     memory location = (base register) + (index register) + (data register)
** Concurrency Control
   There is a 𝘣𝘶𝘪𝘭𝘵-𝘪𝘯 memory interlock in SHAM, as with most modern computers,
   that will prevent garbling of data on a memory store or fetch command when
   two or more processors are concurrently accessing primary memory. This takes
   the form of a tie resolution by the mutually exclusive access to a byte or a
   word. Indefinite postponement (starvation) is avoided in SHAM by a poling of
   any waiting processes, so that effectively a first-come, first-served queue
   is formed. There is also a command called testandset that may be used with
   any designated word address to write lock and unlock software procedures to
   control concurrent processes. There is a stack mechanism, using the SR and SP
   registers to allow the user to create stack arrays in primary memory for
   reentrant programming techniques.
** The Command Repertoire
   The command repertoire of SHAM is: (all numerical values are hexadecimal)
          +---------------+---------+-------------------------------+
          |NOT            |   00    |These are one byte commands.   |
          +---------------+---------+                               |
          |RANDOM         |   01    |                               |
          +---------------+---------+                               |
          |RETURN         |   02    |                               |
          +---------------+---------+                               |
          |TERMINATE      |   03    |                               |
          +---------------+---------+                               |
          |TRACE_ON       |   04    |                               |
          +---------------+---------+                               |
          |TRACE_OFF      |   05    |                               |
          +---------------+---------+                               |
          |ENABLE         |   06    |                               |
          +---------------+---------+                               |
          |DISABLE        |   07    |                               |
          +---------------+---------+-------------------------------+
          |NEGATE         |   08    |These are two byte commands.   |
          +---------------+---------+                               |
          |INCREMENT      |   09    |                               |
          +---------------+---------+                               |
          |DECREMENT      |   0A    |                               |
          +---------------+---------+                               |
          |CLEAR          |   0B    |                               |
          +---------------+---------+                               |
          |PUSH           |   0C    |                               |
          +---------------+---------+                               |
          |POP            |   0D    |                               |
          +---------------+---------+                               |
          |MOVE           |   0E    |                               |
          +---------------+---------+                               |
          |ADD            |   0F    |                               |
          +---------------+---------+                               |
          |SUBTRACT       |   10    |                               |
          +---------------+---------+                               |
          |MULTIPLY       |   11    |                               |
          +---------------+---------+                               |
          |DIVIDE         |   12    |                               |
          +---------------+---------+                               |
          |COMPARE        |   13    |                               |
          +---------------+---------+-------------------------------+
          |IN             |   14    |These are four byte commands   |
          +---------------+---------+and indirect addressing is 10  |
          |OUT            |   15    |more.                          |
          +---------------+---------+                               |
          |BRANCH         |   16    |                               |
          +---------------+---------+                               |
          |CALL           |   17    |                               |
          +---------------+---------+                               |
          |FETCH_BYTE     |   18    |                               |
          +---------------+---------+                               |
          |FETCH_WORD     |   19    |                               |
          +---------------+---------+                               |
          |STORE_BYTE     |   1A    |                               |
          +---------------+---------+                               |
          |STORE_WORD     |   1B    |                               |
          +---------------+---------+                               |
          |STREAM         |   1C    |                               |
          +---------------+---------+                               |
          |TESTANDSET     |   1D    |                               |
          +---------------+---------+                               |
          |INTERRUPT      |   1E    |                               |
          +---------------+---------+-------------------------------+
  A command to store a byte from the AX register to relative address 32 modified
  by index register CX would look like this:
  #+BEGIN_SRC asm
  1A130020
  #+END_SRC
  but no one ever writes code in machine language, an assembler is used. In the
  SHAM system, a cross assembler is provided. Written in the high level language
  C, the cross assembler will produce output that may be stored on SHAM.ROM or
  on SHAM.STM for further input into the SHAM memory. That is, the cross
  assembler transforms a character oriented source file into a binary file of
  the proper structure for loading into SHAM, either on IPL (from SHAM.ROM) or
  bit the use of the STREAM command (from SHAM.STM). It is the user's
  responsibility to create these external files (.ROM and .STM).
* Footnotes

[fn:1] This was the original implementation circa 1988, when I received the
original materials.
