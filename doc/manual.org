# -*- fill-column: 80; abbrev-mode: t  -*-

* Specific Machine Structure
** Simulated Computers
   A computer may be built or it may be simulated or it may be emulated. The
   first is called a ùò≠ùò™ùòµùò¶ùò≥ùò¢ùò≠ machine and actually exists, consisting of chips
   and wires that can be felt and occupy space. The second and third are
   nonexistent machines, but exist logically. They are called ùò∑ùò™ùò≥ùòµùò∂ùò¢ùò≠
   machines. The distinction between simulation and emulation is that simulation
   is done by writing a program and executing it on some host computer, while
   emulation is done in hardware. Emulation is generally faster in execution
   than simulation but lacks the flexibility of easy program modification. There
   is even a compromise approach, in which a micro-program is loaded into an
   emulator, that tries to combine speed of execution with flexibility. There
   are many reasons to have virtual machines. A computer vendor might encourage
   the sales of their[sic] computers by including emulation hardware that
   imitates the commands of a competitor's machine. This would encourage the
   sale of their[sic] ùò£ùò¶ùòµùòµùò¶ùò≥ machine without the customer having to sacrifice
   the present inventory of programs written in the the competitor's machine
   language. Another use, using emulation for high speeds, is to design virtual
   machines that have their ùòÆùò¢ùò§ùò©ùò™ùòØùò¶ ùò≠ùò¢ùòØùò®ùò∂ùò¢ùò®ùò¶ one of the higher level languages,
   such as Pascal or Ada, in order to completely avoid program translation.
   Simulated computers might be used there the need for speed is second to
   flexibility, as in the evaluation of new computer designs before actual
   production begins or to provide testing of programs before prototypes are
   constructed. Another reason of simulation is to provide a machine structure
   for educational purposes.

** The SHAM Computer
   The SHAM computer (an acronym of simplified hypothetical alphanumeric
   machine) is a virtual, or simulated, machine that can be used to study the
   principles of system programming without concern about the limitations,
   availability, or complications of a real machine. SHAM is a simulated
   computer designed for educational purposes. It is simplified to avoid
   cumbersome and educationally unimportant details but has typical machine
   structure from a programmer's viewpoint. The use of SHAM provides for
   portability of the exercises and examples used to teach system programming
   and permits the student to avoid the choking details that must be faced with
   literal machines before anything may be done. The concept of a VM is widely
   used, even to the extent of a large mainframe computer witching from one
   virtual machine to another at millisecond intervals so that each user on such
   a time-slicing system may have a completely different machine to work with. A
   VM simulation is accomplished by writing the behavior of a virtual machine in
   a high level language, compiling this program to the low level hardware
   language of some host computer, and executing the resultant program which
   then behaves as though it were a computer: in this case the SHAM computer.
   The SHAM computer is written in the C language.[fn:1]

** SHAM Overview
   The structure of SHAM is selected to reflect the performance of a typical
   computer, to provide a target computer for the design of operating systems,
   and to provide irritating machine limitations that are so typical of real
   computers. The latter point is included to give realistic experience of the
   type encountered when designing operating systems for actual computers. As an
   example of ease of usage, SHAM includes an instruction to place a random
   number in the AX register. No real machine provides this, a software routine
   is always required. Thus, SHAM makes it simple to generate test data to
   evaluate its performance in different situations. On the other hand, the use
   of SHAM requires attention to different methods of addressing: absolute
   addressing, relative addressing using the DR register, stack addressing with
   the SR register, special behavior of the FX register, and indirect
   addressing. These peculiarities of one machine versus another are a major
   reason for the difficulty in porting operating system software from one
   machine environment to another. Finally, being written in a high level
   language the SHAM computer may be easily modified to study the impact of
   machine structure on system software design and performance.

   It is assumed that SHAM will be implemented on a host computer that has a
   keyboard for data entry, a video display for standard output, and a secondary
   memory for simulation of SHAM's disk memory and streaming input. No printer
   is involved in the SHAM system and  any hard copy will have to be provided by
   the host system, perhaps by redirecting the standard output to a file for
   subsequent printing. The host machine secondary memory will actually hold
   four files: SHAM.ROM, SHAM.STM, SHAM.DSK and SHAM.TXT, The first will
   simulate a ROM, or read only memory, on which the operating system program
   will be stored. When SHAM is activated, that program will automatically load
   into the SHAM internal RAM memory beginning at address location 0. The
   program will start executing from location 0 after loading is completed; this
   simulates the IPL or initial program loading of all computers, In the SHAM
   system, the contents of SHAM.ROM may not be directly addressed: assume that
   the RAM memory is faster than the ROM memory and that the transfer from ROM
   to RAM is to take advantage of that fact. the RAM memory is volatile; i.e.,
   its contents disappear when the power is turned off (a SHAM session is
   terminated) while the ROM memory is permanent. The second file (SHAM.STM) is
   designed to be an auxiliary ROM memory that may contain a machine procedure
   that could be dynamically loaded by the operating system and will serve as a
   vehicle for transferring a machine language (non-text) file onto the
   SHAM.DSK. The last two files (SHAM.DSK and SHAM.TXT) will be used to simulate
   a single disk drive (SHAM.DSK) and the cassette (SHAM.TXT) for secondary
   memory storage. It is anticipated that the operating system will be written
   that will ùòßùò∞ùò≥ùòÆùò¢ùòµ the simulated disk drive to whatever number of 256 byte
   sectors is desired. Data and programs will be stored by SHAM machine language
   programs using commands that read from and write to disk (SHAM.DSK). The text
   file (SHAM.TXT) may be used by SHAM programs to input a stream of bytes into
   the SHAM primary memory.

   SHAM is deliberately limited in its design in order to achieve simplicity.
   Those structures that do not relate to operating system design are omitted.
   There is but a single disk drive There is no floating point, only small
   integer arithmetic is permitted. There is no divide overflow interrupt. SHAM
   does not provide relative timing in its simulation. The commands do take
   different real time intervals for execution depending on their complexity but
   there is, for example, no attempt to simulate the tremendous differences in
   steed between register aces and primary memory access, which differ by factors
   up to several thousand in real machines.

   Certain commands are missing in SHAM that might be found in other processors.
   There are, for example, no bit manipulation commands in SHAM. There are no
   register shift op-codes. The flag register will only indicate three level and
   is not used to record results of arithmetic carry or of divide overflow or of
   parity failure in data manipulation.

** Input and Output Operations
   There are four peripheral i-o devices on SHAM, a keyboard input, a video output
   call Input-Output, a video output call [sic] Display and the tape-like file
   called Textile (SHAM.TXT). The two video devices (input-Output and Display)
   are displayed side by side on the host machine video display output. All of
   these input-output devices are one character at a time units. The characters
   are transferred directly into or from primary memory locations without
   interference with processor or secondary memory access. There is no direct
   connection between the registers and output ports and characters will have to
   stored [sic] in memory and then outputted. Non-graphic characters are
   handled differently on SHAM than many machines (but that is true for those
   many machines, i-o differences make operating system potability a problem).
   On the Input-Output display, the backspace will move the cursor backwards
   (its[sic] the only cursor control) and will output the character previously
   displayed in white ink as opposed to the normal black ink, thus erasing the
   previously displayed character. The carriage return acts like the carriage
   return on old-fashioned typewriters; i.e., it not only returns the cursor to
   the leftmost position but it issues a line feed. The combustion carriage
   return and line feed, required on some computers, is not needed on SHAM. The
   ASCII control character for carriage-return[sic] is encoded as the number 13.
   There is no cursor control for the display units and no graphic facilities,
   just character output. There is no on-line printer, thus avoiding the problem
   of escape sequences, but the Display video acts like a printer in that no
   backspace may take place. There are no communication ports. There are no
   light pen or mouse inputs.
** Primary and Secondary Memory
   The internal memory, or RAM, is simulated to be 32678 bytes of storage that
   will volatilize when the SHAM program is terminated. The 32K bytes in the RAM
   are addressable from 0 through 32677. In addition to byte addressing, word
   referencing is permitted by commands that fetch or store two contiguous
   bytes. This is true for all addresses, whether odd or even. except for the last
   byte at 323677; there is no byte following that one (the memory is not
   circular).

   The single 32 KB primary memory is used to store both programs and data.
   Certain addresses in lower memory should be avoided in programming; as with
   many computers these locations are reserved for machine purposes, such as an
   interrupt vector. It would have been simple to make the SHAM primary memory
   larger. all that is required is to change the dimension in the memory
   descriptor in the source program:

   #+BEGIN_SRC c
   #define MEM_SIZE 32768
   char memory[MEM_SIZE];  /* SHAM internal memory */
   #+END_SRC

   However, the use of the smaller 32 KB memory will ensure the design of an
   operating system that efficiently utilizes memory allocation. The same point
   can be made about the SHAM word size, which is 16 bits (two bytes), A simple
   change in the source program to define the integers as ùò≠ùò∞ùòØùò® would suffice,
   but the smaller word forces the designer to be more conscious of hardware
   limitations.

   The secondary memory simulates a disk drive, with fixed sector size of 256
   bytes. An entire sector is read to or written from primary memory by machine
   command. There is no hardware buffer, the sector is coped directly into or
   from primary memory starting at any specified address low enough from 32677 to
   allow for a full sector (there is no memory wraparound). The timing of the
   sector transfer is determined by the host computer since the SHAM.DSK drive
   is simulated by a host computer disk file.

** The Fetch-Execute Cycle
   The design of a computer requires a working memory to hold the stored program
   and a processing unit to interpret the commands of the program and effect
   their execution. In the simplest case, a program consists of a sequence of
   commands that are stored in some high speed memory accessible to the
   processing unit.  A command is copied from the memory into a small storage unit
   called a command register. The command register is not available to the
   programmer. The command will consist of a series of bits and might look
   something like this:
   #+BEGIN_SRC asm
   0110110101110010
   #+END_SRC
   That particular combination of bits, represented by a sequence of bistable
   devices in the command register, would cause the processing unit to initiate
   some simple action, such as: add two numbers. Such an action would be only
   one in a long series of steps required to direct the computer to obtain some
   meaningful results. The processing unit would then fetch the next command in
   sequence to the command register, erasing the previous command, and replacing
   it with something like:
   #+BEGIN_SRC asm
   1001101111011111
   #+END_SRC
   which might direct the processing unit to multiply the previous sum be a
   third number. These two steps:
   1. fetch the next command in the program
   2. interpret and execute that command
   are the heart beat of the computer. The processing unit repeats that cycle
   endlessly: fetch and execute. The actions of the computer are entirely the
   result of the bit patterns stored in the program memory. These bit patterns
   are store in some magnetic or electronic device; the exact device depending
   on he type of computer and the year in which it was built. Programmers who
   can create these bit patterns and enter then[sic] into the correct locations
   in program memory are programming at the machine level of detail and this
   action is referred to a machine language programming.

** C Simulation Program
   The following C language function is the main cycle of the SHAM computer:
   #+BEGIN_SRC c
   main() {
       char memory[MEM_SIZE]; /* SHAM internal memory. */
       r1 = 0;                /* Boot from SHAM.ROM.   */
       stream(memory);

       /* The cycle is repeated endlessly. */
       while (1) {
           fetch(memory);    /* Fetch instruction.  */
           execute(memory);  /* Execute instruction. */
       }
   }
   #+END_SRC
   The memory is declared as an array of type character with a size specified by
   MEM_SIZE (which is 32678.) The subscripts for this array may range from 0
   to 32577. The first action of the "main" procedure is to "boot up" by reading
   the file SHAM.ROM into memory starting at zero, by calling the function
   stream(memory) with r1 set to zero. Then SHAM (until a TERMINATE instruction
   is executed) fetches the next instruction from memory and then executes that
   instruction via a call to a different C function (not shown here) for each
   instruction.

** The Processing Unit
   The structure of the processing unit consists of the high speed registers
   and the circuitry required to analyze the command bit pattern and to control
   the rest of the computer. This circuitry determines the command repertoire of
   the particular machine. To properly utilize a computer, the machine level
   programmer must know what that repertoire is. Computers manufactured by
   different vendors will have dissimilar command sets, and frequently,
   different models within one vendor will too. This means that a programmer who
   knows how to program one machine; i.e., to create the bit patterns to control
   the computer cannot use that knowledge to program any other type of computer.
   In addition to the command register and the control circuitry, the processing
   unit requires a "next location" register which enables the unit to fetch the
   next command in proper sequence. Remember, fetch is a copy operation, and
   the original commanded in the program memory is not destroyed or altered by
   being fetched. The next location register, also called the instruction
   pointer register, is automatically changed after the fetch (and sometimes by
   the program command itself in the execute phase) so that it points to the
   next command to be executed. How the location register is initialized to
   point to the first command in the program varies from one machine to
   another, but one solution is to have the programs always start from the same
   location in memory. In SHAM , the IP (instruction pointer) register is set to
   zero when the simulation program is initiated (Initial Program Load is what it
   is called) and all application programs must start with their first command
   in location zero of the SHAM primary memory.

   There are other registers in the processing unit. These are often combined
   with the registers in the computer's arithmetic and logical unit as general
   purpose registers. These registers are used in address modifications as well
   as arithmetic calculations.

** Register Memory
   There are eleven registers in SHAM. All registers are of word length (16
   bits), All arithmetic is word oriented and of integer mode; there are no
   floating point or real arithmetic commands in the SHAM repertoire. Five
   registers are general purpose: these are named the AX, BX, CX, DX, and EX
   registers. The FX register (sometimes referred to as the frame register) is
   similar except that when it appears as the second register in a four-byte
   SHAM command the SR (stack register) contents are added to the FX contents
   rather than the DR (data register) which is done for all other relative
   addressing. In addition to these six, there are the DR, IP, SR, SP, and the
   FR registers. The FR is a flag register, and although it is 16 bits long, is
   used only to contain a flag of value -1, 0, +1 to indicate the result of a
   previous compare command. The DR register is used as the base register for
   procedure relocation. The contents of the IP register, the command address
   offsets, and the indirect addresses in other registers are each added to the
   contents of DR before execution to produce a machine memory address that is
   the sum of some base address and some displacement. The IP register is the
   instruction pointer and contains the address of the next command in memory
   to be fetched and executed. The SP (stack register)contains the base address
   of some location in memory to be used in stack addressing(in such commands as
   PUSH, POP, CALL, and RETURN). The SP (stack pointer) contains an offset that
   is added to the contents of SR to create the actual stack address and it is
   the SP register that is changed by a command such as PUSH or POP. The
   contents of DR,IP, SR, and SP are set during IPL. The value of DR and IP are
   each set to zero, so that the program in ROM must start execution at absolute
   address of zero. The contents of SR are set by IPL to a value just larger
   than the program read in from ROM so that the first stack established lies in
   the memory jut after the ROM program. The value of SP is set to 600, so tat
   there is an initial stack large enough for most application,. The user
   program may change any of these values subsequently. In summary:
   | SHAM high-speed 16 bit register memory |                                                                                 |
   |----------------------------------------+---------------------------------------------------------------------------------|
   | AX                                     | Five                                                                            |
   | BX                                     | general                                                                         |
   | CX                                     | purpose                                                                         |
   | DX                                     | arithmetic                                                                      |
   | EX                                     | registers.                                                                      |
   | FX                                     | Frame register (may be used in arithmetic.)                                     |
   | DR                                     | Restricted to point to next                                                     |
   | IP                                     | instruction to be fetched.                                                      |
   | SR                                     | Restricted to point to a user                                                   |
   | SP                                     | specified stack in memory.                                                      |
   | FR                                     | Flag register (set by compare command and used by conditional branch commands.) |


** Interrupts and Reserved Vector
* Footnotes

[fn:1] This was the original implementation circa 1988, when I received the
original materials.
