# -*- fill-column: 80; abbrev-mode: t  -*-

* Specific Machine Structure
** Simulated Computers
   A computer may be built or it may be simulated or it may be emulated. The
   first is called a ğ˜­ğ˜ªğ˜µğ˜¦ğ˜³ğ˜¢ğ˜­ machine and actually exists, consisting of chips
   and wires that can be felt and occupy space. The second and third are
   nonexistent machines, but exist logically. They are called ğ˜·ğ˜ªğ˜³ğ˜µğ˜¶ğ˜¢ğ˜­
   machines. The distinction between simulation and emulation is that simulation
   is done by writing a program and executing it on some host computer, while
   emulation is done in hardware. Emulation is generally faster in execution
   than simulation but lacks the flexibility of easy program modification. There
   is even a compromise approach, in which a micro-program is loaded into an
   emulator, that tries to combine speed of execution with flexibility. There
   are many reasons to have virtual machines. A computer vendor might encourage
   the sales of their[sic] computers by including emulation hardware that
   imitates the commands of a competitor's machine. This would encourage the
   sale of their[sic] ğ˜£ğ˜¦ğ˜µğ˜µğ˜¦ğ˜³ machine without the customer having to sacrifice
   the present inventory of programs written in the the competitor's machine
   language. Another use, using emulation for high speeds, is to design virtual
   machines that have their ğ˜®ğ˜¢ğ˜¤ğ˜©ğ˜ªğ˜¯ğ˜¦ ğ˜­ğ˜¢ğ˜¯ğ˜¨ğ˜¶ğ˜¢ğ˜¨ğ˜¦ one of the higher level languages,
   such as Pascal or Ada, in order to completely avoid program translation.
   Simulated computers might be used there the need for speed is second to
   flexibility, as in the evaluation of new computer designs before actual
   production begins or to provide testing of programs before prototypes are
   constructed. Another reason of simulation is to provide a machine structure
   for educational purposes.

** The SHAM Computer
   The SHAM computer (an acronym of simplified hypothetical alphanumeric
   machine) is a virtual, or simulated, machine that can be used to study the
   principles of system programming without concern about the limitations,
   availability, or complications of a real machine. SHAM is a simulated
   computer designed for educational purposes. It is simplified to avoid
   cumbersome and educationally unimportant details but has typical machine
   structure from a programmer's viewpoint. The use of SHAM provides for
   portability of the exercises and examples used to teach system programming
   and permits the student to avoid the choking details that must be faced with
   literal machines before anything may be done. The concept of a VM is widely
   used, even to the extent of a large mainframe computer witching from one
   virtual machine to another at millisecond intervals so that each user on such
   a time-slicing system may have a completely different machine to work with. A
   VM simulation is accomplished by writing the behavior of a virtual machine in
   a high level language, compiling this program to the low level hardware
   language of some host computer, and executing the resultant program which
   then behaves as though it were a computer: in this case the SHAM computer.
   The SHAM computer is written in the C language.[fn:1]

** SHAM Overview
   The structure of SHAM is selected to reflect the performance of a typical
   computer, to provide a target computer for the design of operating systems,
   and to provide irritating machine limitations that are so typical of real
   computers. The latter point is included to give realistic experience of the
   type encountered when designing operating systems for actual computers. As an
   example of ease of usage, SHAM includes an instruction to place a random
   number in the AX register. No real machine provides this, a software routine
   is always required. Thus, SHAM makes it simple to generate test data to
   evaluate its performance in different situations. On the other hand, the use
   of SHAM requires attention to different methods of addressing: absolute
   addressing, relative addressing using the DR register, stack addressing with
   the SR register, special behavior of the FX register, and indirect
   addressing. These peculiarities of one machine versus another are a major
   reason for the difficulty in porting operating system software from one
   machine environment to another. Finally, being written in a high level
   language the SHAM computer may be easily modified to study the impact of
   machine structure on system software design and performance.

   It is assumed that SHAM will be implemented on a host computer that has a
   keyboard for data entry, a video display for standard output, and a secondary
   memory for simulation of SHAM's disk memory and streaming input. No printer
   is involved in the SHAM system and  any hard copy will have to be provided by
   the host system, perhaps by redirecting the standard output to a file for
   subsequent printing. The host machine secondary memory will actually hold
   four files: SHAM.ROM, SHAM.STM, SHAM.DSK and SHAM.TXT, The first will
   simulate a ROM, or read only memory, on which the operating system program
   will be stored. When SHAM is activated, that program will automatically load
   into the SHAM internal RAM memory beginning at address location 0. The
   program will start executing from location 0 after loading is completed; this
   simulates the IPL or initial program loading of all computers, In the SHAM
   system, the contents of SHAM.ROM may not be directly addressed: assume that
   the RAM memory is faster than the ROM memory and that the transfer from ROM
   to RAM is to take advantage of that fact. the RAM memory is volatile; i.e.,
   its contents disappear when the power is turned off (a SHAM session is
   terminated) while the ROM memory is permanent. The second file (SHAM.STM) is
   designed to be an auxiliary ROM memory that may contain a machine procedure
   that could be dynamically loaded by the operating system and will serve as a
   vehicle for transferring a machine language (non-text) file onto the
   SHAM.DSK. The last two files (SHAM.DSK and SHAM.TXT) will be used to simulate
   a single disk drive (SHAM.DSK) and the cassette (SHAM.TXT) for secondary
   memory storage. It is anticipated that the operating system will be written
   that will ğ˜§ğ˜°ğ˜³ğ˜®ğ˜¢ğ˜µ the simulated disk drive to whatever number of 256 byte
   sectors is desired. Data and programs will be stored by SHAM machine language
   programs using commands that read from and write to disk (SHAM.DSK). The text
   file (SHAM.TXT) may be used by SHAM programs to input a stream of bytes into
   the SHAM primary memory.

   SHAM is deliberately limited in its design in order to achieve simplicity.
   Those structures that do not relate to operating system design are omitted.
   There is but a single disk drive There is no floating point, only small
   integer arithmetic is permitted. There is no divide overflow interrupt. SHAM
   does not provide relative timing in its simulation. The commands do take
   different real time intervals for execution depending on their complexity but
   there is, for example, no attempt to simulate the tremendous differences in
   steed between register aces and primary memory access, which differ by factors
   up to several thousand in real machines.

   Certain commands are missing in SHAM that might be found in other processors.
   There are, for example, no bit manipulation commands in SHAM. There are no
   register shift op-codes. The flag register will only indicate three level and
   is not used to record results of arithmetic carry or of divide overflow or of
   parity failure in data manipulation.

** Input and Output Operations
   There are four peripheral i-o devices on SHAM, a keyboard input, a video output
   call Input-Output, a video output call [sic] Display and the tape-like file
   called Textile (SHAM.TXT). The two video devices (input-Output and Display)
   are displayed side by side on the host machine video display output. All of
   these input-output devices are one character at a time units. The characters
   are transferred directly into or from primary memory locations without
   interference with processor or secondary memory access. There is no direct
   connection between the registers and output ports and characters will have to
   stored [sic] in memory and then outputted. Non-graphic characters are
   handled differently on SHAM than many machines (but that is true for those
   many machines, i-o differences make operating system potability a problem).
   On the Input-Output display, the backspace will move the cursor backwards
   (its[sic] the only cursor control) and will output the character previously
   displayed in white ink as opposed to the normal black ink, thus erasing the
   previously displayed character. The carriage return acts like the carriage
   return on old-fashioned typewriters; i.e., it not only returns the cursor to
   the leftmost position but it issues a line feed. The combustion carriage
   return and line feed, required on some computers, is not needed on SHAM. The
   ASCII control character for carriage-return[sic] is encoded as the number 13.
   There is no cursor control for the display units and no graphic facilities,
   just character output. There is no on-line printer, thus avoiding the problem
   of escape sequences, but the Display video acts like a printer in that no
   backspace may take place. There are no communication ports. There are no
   light pen or mouse inputs.
** Primary and Secondary Memory
   The internal memory, or RAM, is simulated to be 32678 bytes of storage that
   will volatilize when the SHAM program is terminated. The 32K bytes in the RAM
   are addressable from 0 through 32677. In addition to byte addressing, word
   referencing is permitted by commands that fetch or store two contiguous
   bytes. This is true for all addresses, whether odd or even. except for the last
   byte at 323677; there is no byte following that one (the memory is not
   circular).

   The single 32 KB primary memory is used to store both programs and data.
   Certain addresses in lower memory should be avoided in programming; as with
   many computers these locations are reserved for machine purposes, such as an
   interrupt vector. It would have been simple to make the SHAM primary memory
   larger. all that is required is to change the dimension in the memory
   descriptor in the source program:

   #+BEGIN_SRC c
   #define MEM_SIZE 32768
   char memory[MEM_SIZE];  /* SHAM internal memory */
   #+END_SRC

   However, the use of the smaller 32 KB memory will ensure the design of an
   operating system that efficiently utilizes memory allocation. The same point
   can be made about the SHAM word size, which is 16 bits (two bytes), A simple
   change in the source program to define the integers as ğ˜­ğ˜°ğ˜¯ğ˜¨ would suffice,
   but the smaller word forces the designer to be more conscious of hardware
   limitations.

   The secondary memory simulates a disk drive, with fixed sector size of 256
   bytes. An entire sector is read to or written from primary memory by machine
   command. There is no hardware buffer, the sector is coped directly into or
   from primary memory starting at any specified address low enough from 32677 to
   allow for a full sector (there is no memory wraparound). The timing of the
   sector transfer is determined by the host computer since the SHAM.DSK drive
   is simulated by a host computer disk file.

** The Fetch-Execute Cycle
   The design of a computer requires a working memory to hold the stored program
   and a processing unit to interpret the commands of the program and effect
   their execution. In the simplest case, a program consists of a sequence of
   commands that are stored in some high speed memory accessible to the
   processing unit.  A command is copied from the memory into a small storage unit
   called a command register. The command register is not available to the
   programmer. The command will consist of a series of bits and might look
   something like this:
   #+BEGIN_SRC asm
   0110110101110010
   #+END_SRC
   That particular combination of bits, represented by a sequence of bistable
   devices in the command register, would cause the processing unit to initiate
   some simple action, such as: add two numbers. Such an action would be only
   one in a long series of steps required to direct the computer to obtain some
   meaningful results. The processing unit would then fetch the next command in
   sequence to the command register, erasing the previous command, and replacing
   it with something like:
   #+BEGIN_SRC asm
   1001101111011111
   #+END_SRC
   which might direct the processing unit to multiply the previous sum be a
   third number. These two steps:
   1. fetch the next command in the program
   2. interpret and execute that command
   are the heart beat of the computer. The processing unit repeats that cycle
   endlessly: fetch and execute. The actions of the computer are entirely the
   result of the bit patterns stored in the program memory. These bit patterns
   are store in some magnetic or electronic device; the exact device depending
   on he type of computer and the year in which it was built. Programmers who
   can create these bit patterns and enter then[sic] into the correct locations
   in program memory are programming at the machine level of detail and this
   action is referred to a machine language programming.cc

* Footnotes

[fn:1] This was the original implementation circa 1988, when I received the
original materials.
